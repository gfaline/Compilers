\section{Lexical Conventions}

\subsection{Comments}
Propeller supports single-line comments. Any sequence of characters following a hash (\verb|#|) that is not part of a
string literal will be treated as a comment. Comments automatically terminate at the end of a line.

\begin{wrapfigure}{r}{0.25\textwidth}
\vspace{-4.5cm}
\begin{mylistingn}
# This is a comment.

# valid identifiers
x
ready?
aBc123
o_o
AsDfG_1234_5?

# invalid identifiers
8eight
two__underscores
propeller_
too?early
huh_?
\end{mylistingn}
\end{wrapfigure}

% RESTRUCTURED
% - <digit> was undefined
% - <alphnum> makes the expression much easier to read
\subsection{Identifiers}
% \begin{verbatim}
%     <letter> ::= "A"-"Z" | "a"-"z"
% <identifier> ::= <letter> ("?" | "")
%               | <letter> ("_" | "")
%                {(<letter> | <digit>) |
%                 ((<letter> | <digit>) "_")}
%               (<letter> | <digit>) ("?" | "")
% \end{verbatim}
\begin{verbatim}
    <letter> ::= "A"-"Z" | "a"-"z"
    <digit>  ::= "0"-"9"
  <alphnum>  ::= <letter> | <digit>
<identifier> ::= <letter> ("?" | "")
               | <letter> ("_" | "") {<alphnum> | <alphnum> "_"}
                 <alphnum> ("?" | "")
\end{verbatim}

% REWORDED
% To put this rather cryptic identifier rule in plain English: only letters, digits, underscores and
% question mark are allowed in identifier names. They must start with a letter, and must not end with
% an underscore. The question mark can only appear at the end, and two punctuation marks cannot appear
% consecutively.
% - while this explanation is technically correct, I think the following is more straightforward:
An identifier in Propeller is a character sequence consisting of letters, digits, underscores, and one
optional question mark. Identifiers must begin with letters, cannot contain consecutive underscores,
and cannot end with an underscore. Additionally, identifiers may end with a single question mark,
but may not end with an underscore followed by a question mark.

\subsection{Keywords}
Propeller has 25 reserved keywords:
\begin{mylistingn}
and  bind     break continue elif
else external float fn       for
from if       int   list     not
obj  objdef   or    return   str
to   unbind   void  while    xor                     
\end{mylistingn}

\subsection{Separators}
Propeller has 10 separators used to construct literals, define functions, separate statements, and
more:
\begin{mylistingn}
( ) [ ] { }
, . ;   ->
\end{mylistingn}

\clearpage

\subsection{Operators}
Propeller has 15 operators for comparison, logic, and arithmetic.
\begin{mylistingn}
# comparison  logic  arithmetic
  =           and    +
  !=          or     -
  >           not    *
  <           xor    /
  >=                 %
  <=
\end{mylistingn}

\subsection{Literals}
% SMALL CHANGE
% \begin{verbatim}
%             <digit> ::= "0"-"9"
%       <int-literal> ::= {<digit>}
%     <float-literal> ::= {<digit>} "." {<digit>}
%      <bool-literal> ::= "true" | "false"
% <string-characters> ::= character or escape sequence
%    <string-literal> ::= "'" {<string-characters>} "'"
% \end{verbatim}
% - removed redefinition of <digit>
\begin{verbatim}
      <int-literal> ::= {<digit>}
    <float-literal> ::= {<digit>} "." {<digit>}
     <bool-literal> ::= "true" | "false"
<string-characters> ::= character or escape sequence
   <string-literal> ::= "'" {<string-characters>} "'"
\end{verbatim}

\noindent Escape sequences in string literals are interpreted the same way OCaml
interprets them (as in \verb|Scanf.unescaped|).

\begin{mylistingn}
# int literals     float literals     boolean literals       string literals
1                  3.14               true                   'hello'
23                 0.78               false                  'h0wdy!'
0                  12.345                                    '\twhat\'s up?\n'
5839407430         0.999
\end{mylistingn}

% vim: tw=100 spell spelllang=en_us
