\section{Appendix D: Full source code listing of the compiler}

\subsection{\texttt{scanner.mll}}

\begin{lstlisting}[language=Caml,backgroundcolor=\color{backgroundcolor}]
(* Authors: Isra Ali, Gwendolyn Edgar, Randy Price, Chris Xiong *)
(* scanner for Propeller language *)

{ open Parser }

let letter = ['a'-'z' 'A'-'Z']
let digit  = ['0'-'9']
let alphnum = letter | digit
let identifier = letter '?'?
         | letter '_'? ( alphnum | alphnum '_')* alphnum '?'?

(* parse input *)
rule token = parse
  (* whitespace/comments *)
    [' ' '\t' '\r' '\n'] { token lexbuf }
  | '#' { comment lexbuf }
  (* syntactical symbols *)
  | '('      { LPAREN }
  | ')'      { RPAREN }
  | '{'      { LBRACE }
  | '}'      { RBRACE }
  | '['      { LBRCKT }
  | ']'      { RBRCKT }
  | ';'      { SEMI }
  | ','      { COMMA }
  | "fn"     { FN }
  | "->"     { ARROW }
  | '.'      { PERIOD }
  (* arithemtic operators *)
  | '+'      { PLUS }
  | '-'      { MINUS }
  | '*'      { TIMES }
  | '/'      { DIVIDE }
  | '%'      { MODULO }
  | '='      { ASSIGN }
  (* comparison operators *)
  | "=="     { EQ }
  | "!="     { NEQ }
  | '<'      { LT }
  | "<="     { LEQ }
  | ">"      { GT }
  | ">="     { GEQ }
  (* logical operators *)
  | "not"    { NOT }
  | "xor"    { XOR }
  | "and"    { AND }
  | "or"     { OR  }
  (* control flow *)
  | "for"    { FOR }
  | "from"   { FROM }
  | "to"     { TO }
  | "if"     { IF }
  | "elif"   { ELIF }
  | "else"   { ELSE }
  | "while"  { WHILE }
  | "break"  { BREAK }
  | "continue" { CONTINUE }
  | "return" { RETURN }
  (* Propeller stuff *)
  | "objdef" { OBJDEF }
  | "bind"   { BIND }
  | "unbind" { UNBIND }
  | "external" { EXTERNAL }
  (* primitive types *)
  | "obj"    { OBJ }
  | "int"    { INT }
  | "bool"   { BOOL }
  | "float"  { FLOAT }
  | "str"    { STR }
  | "void"   { VOID }
  | "list"   { LIST }
  (* literals *)
  | digit+ as x            { ILIT(int_of_string x)   } 
  | digit+ '.' digit+ as x { FLIT(float_of_string x) }
  | "true"                 { BLIT(true) }
  | "false"                { BLIT(false) }
  | ''' [^''']*'''    as s { SLIT(s) }
  (* names *)
  | identifier   as id { ID(id) }
  | eof { EOF }
  | _ as char { raise (Failure("illegal character " ^ Char.escaped char)) }

  and comment = parse
      '\n' { token lexbuf }
    | eof  { token lexbuf }
    | _    { comment lexbuf }
\end{lstlisting}

\subsection{\texttt{parser.mly}}

\begin{lstlisting}[language=Caml,backgroundcolor=\color{backgroundcolor}]
/* Authors: Isra Ali, Gwendolyn Edgar, Randy Price, Chris Xiong */
/* Ocamlyacc parser for Propeller */

%{ open Ast %}

%token SEMI LPAREN RPAREN LBRACE RBRACE COMMA OBJDEF FN ARROW ASSIGN PLUS MINUS TIMES DIVIDE MODULO
%token NOT EQ NEQ LT LEQ GT GEQ XOR AND OR
%token EXTERNAL BIND UNBIND BREAK CONTINUE RETURN IF ELIF ELSE FOR FROM TO WHILE OBJ INT BOOL FLOAT STR VOID LIST
%token PERIOD
%token LBRCKT RBRCKT
%token <int> ILIT
%token <float> FLIT
%token <bool> BLIT
%token <string> SLIT
%token <string> ID
%token EOF

%start program
%type <Ast.program> program

%nonassoc NOELSE
%nonassoc ELSE
%nonassoc ELIF
%right ASSIGN
%left OR
%left AND
%left XOR
%left EQ NEQ
%left LT GT LEQ GEQ
%left PLUS MINUS
%left TIMES DIVIDE MODULO
%right NOT

%%

program:
    decls EOF { $1 }

decls:
    /* nothing */ { ([], [], []) }
  | decls vdecl   { (($2 :: fst_trpl $1), snd_trpl $1, trd_trpl $1) }
  | decls odecl   { (fst_trpl $1, ($2 :: snd_trpl $1), trd_trpl $1) }
  | decls fdecl   { (fst_trpl $1, snd_trpl $1, ($2 :: trd_trpl $1)) }

odecl:
    OBJDEF ID LBRACE vdecl_list RBRACE
      { { oname = $2;
          props = List.rev $4;
          extern = false; } }
  | EXTERNAL OBJDEF ID LBRACE vdecl_list RBRACE
      { { oname = $3;
          props = List.rev $5;
          extern = true; } }

fdecl:
  FN ID LPAREN formals_opt RPAREN ARROW typ LBRACE vdecl_list stmt_list RBRACE
    { { typ     = $7;
        fname   = $2;
        formals = List.rev $4;
        locals  = List.rev $9;
        body    = List.rev $10 } }

formals_opt:
    /* nothing */ { [] }
  | formal_list   { $1 }

formal_list:
    typ ID                   { [($1, $2)] }
  | formal_list COMMA typ ID { ($3, $4) :: $1 }

typ:
    INT   { Int }
  | BOOL  { Bool }
  | FLOAT { Float}
  | STR   { Str }
  | VOID  { Void }
  | OBJ   { Obj }
  | typ LIST { List($1) }

vdecl_list:
    /* nothing */ { [] }
  | vdecl_list vdecl { $2 :: $1 }

vdecl:
    typ ID SEMI { ($1, $2) }
  | ID ID SEMI { (Custom($1), $2) }

stmt_list:
    // /* nothing */ { [] }
    stmt { [$1] }
  | stmt_list stmt { $2 :: $1 }

stmt:
    expr_stmt   { $1 }
  | return_stmt { $1 }
  | if_stmt     { $1 }
  | for_stmt    { $1 }
  | while_stmt  { $1 }
  | BREAK SEMI    { Break }
  | CONTINUE SEMI { Continue }
  | bind_stmt   { $1 }
  | unbind_stmt { $1 }

bind_stmt:
  BIND LPAREN ID PERIOD ID COMMA ID RPAREN SEMI { Bind ($3, $5, $7) }

unbind_stmt:
  UNBIND LPAREN ID PERIOD ID COMMA ID RPAREN SEMI { Unbind ($3, $5, $7) }

expr_stmt:
    expr SEMI { Expr($1) }

return_stmt:
  | RETURN expr_opt SEMI { Return($2) }

if_stmt:
    IF expr LBRACE stmt_list RBRACE elif_stmts else_stmt { If($2, List.rev $4, $6, $7) }

else_stmt:
    %prec NOELSE { [] }
  | ELSE LBRACE stmt_list RBRACE    { List.rev $3 }

elif_stmts:
    /* nothing */ { [] }
  | elif_stmts elif_stmt { $2 :: $1 }

elif_stmt:
  ELIF expr LBRACE stmt_list RBRACE { ($2, List.rev $4) }

for_stmt:
    FOR ID FROM expr TO expr LBRACE stmt_list RBRACE { For($2, $4, $6, List.rev $8) }

while_stmt:
    WHILE expr LBRACE stmt_list RBRACE  { While($2, List.rev $4) }

expr_opt:
    /* nothing */ { Noexpr }
  | expr          { $1     }

expr:
  // literals
    ILIT { Iliteral($1) }
  | FLIT { Fliteral($1) }
  | BLIT { Bliteral($1) }
  | SLIT { Sliteral($1) }
  | LBRCKT args_list RBRCKT   { Lliteral(Array.of_list $2) }
  // ID evaluation
  | ID   { Id($1) }
  | ID PERIOD ID %prec NOT    { Getprop($1, $3) }
  // function call
  | ID LPAREN args_opt RPAREN { Call($1, $3) }
  // assignment
  | ID ASSIGN expr            { Assign($1, $3) }
  | ID PERIOD ID ASSIGN expr  { Setprop($1, $3, $5) }
  // list indexing
  | ID LBRCKT expr RBRCKT     { Index($1, $3) }
  // arithmetic
  | expr PLUS   expr          { Binop($1, Add, $3) }
  | expr MINUS  expr          { Binop($1, Sub, $3) }
  | expr TIMES  expr          { Binop($1, Mlt, $3) }
  | expr DIVIDE expr          { Binop($1, Div, $3) }
  | MINUS expr %prec NOT      { Unop(Neg, $2)  }
  | expr MODULO expr          { Binop($1, Mod, $3) }
  // comparison
  | expr EQ     expr          { Binop($1, Eq,  $3) }
  | expr NEQ    expr          { Binop($1, Neq, $3) }
  | expr LT     expr          { Binop($1, Lt,  $3) }
  | expr LEQ    expr          { Binop($1, Leq, $3) }
  | expr GT     expr          { Binop($1, Gt,  $3) }
  | expr GEQ    expr          { Binop($1, Geq, $3) }
  // logical
  | expr AND    expr          { Binop($1, And, $3) }
  | expr XOR    expr          { Binop($1, Xor, $3) }
  | expr OR     expr          { Binop($1, Or,  $3) }
  | NOT  expr                 { Unop(Not, $2)      }
  // other
  | LPAREN expr RPAREN        { Parentheses($2) }

args_opt:
    /* nothing */ { [] }
  | args_list     { List.rev $1 }

args_list:
    expr                 { [$1]     }
  | args_list COMMA expr { $3 :: $1 }
\end{lstlisting}

\subsection{\texttt{ast.ml}}

\begin{lstlisting}[language=Caml,backgroundcolor=\color{backgroundcolor}]
(* Authors: Isra Ali, Gwendolyn Edgar, Randy Price, Chris Xiong *)
let fst_trpl (a, _, _) = a
let snd_trpl (_, b, _) = b
let trd_trpl (_, _, c) = c

type binop =
    Add
  | Sub
  | Mlt
  | Div
  | Mod
  | Eq
  | Neq
  | Lt
  | Leq
  | Gt
  | Geq
  | Xor
  | And
  | Or

type unop =
    Not
  | Neg

type typ =
    Int
  | Bool
  | Float
  | Str
  | Void
  | Obj
  | List of typ
  | Custom of string

type bind = typ * string

type obj_decl = {
  oname : string;
  props : bind list;
  extern: bool}

type expr =
  (* literals *)
    Iliteral of int
  | Fliteral of float
  | Bliteral of bool
  | Sliteral of string
  | Lliteral of expr array
  (* function call *)
  | Call of string * expr list
  (* assignment *)
  | Assign of string * expr
  | Setprop of string * string * expr
  (* ID evaluation*)
  | Id of string
  | Getprop of string * string
  (* list indexing *)
  | Index of string * expr
  (* operators *)
  | Binop of expr * binop * expr
  | Unop of unop * expr
  (* other *)
  | Parentheses of expr
  | Noexpr

type stmt =
    Expr of expr
  | Return of expr
  | If of expr * stmt list * (expr * stmt list) list * stmt list
  | For of string * expr * expr * stmt list
  | While of expr * stmt list
  | Break
  | Continue
  | Bind of string * string * string
  | Unbind of string * string * string

type func_decl = {
  typ : typ;
  fname : string;
  formals : bind list; 
  locals : bind list;
  body : stmt list }

type program = bind list * obj_decl list * func_decl list

let string_of_binop = function
    Add -> "+"
  | Sub -> "-"
  | Mlt -> "*"
  | Div -> "/"
  | Mod -> "%"
  | Eq  -> "=="
  | Neq -> "!="
  | Lt  -> "<"
  | Leq -> "<="
  | Gt  -> ">"
  | Geq -> ">="
  | Xor -> "xor"
  | And -> "and"
  | Or  -> "or"

let string_of_unop = function
    Not -> "not"
  | Neg -> "-"

let rec string_of_typ = function
    Int   -> "int"
  | Bool  -> "bool"
  | Float -> "float"
  | Str   -> "str"
  | Void  -> "void"
  | Obj   -> "obj"
  | List(t) -> string_of_typ t ^ " list"
  | Custom(t) -> t

let rec string_of_expr = function
  (* literals *)
    Iliteral x -> string_of_int x
  | Fliteral x -> string_of_float x
  | Bliteral x -> if x then "true" else "false"
  | Sliteral x -> x
  | Lliteral xs -> "[" ^ String.concat ", " (Array.to_list (Array.map string_of_expr xs)) ^ "]"
  (* function call *)
  | Call (f, es) -> f ^ "(" ^ String.concat ", " (List.map string_of_expr es) ^ ")"
  (* assignment *)
  | Assign (id, e) -> id ^ " = " ^ string_of_expr e
  | Setprop (o, p, e) -> o ^ "." ^ p ^ " = " ^ string_of_expr e
  (* ID evaluation *)
  | Id id -> id
  | Getprop (o, p) -> o ^ "." ^ p
  (* list indexing *)
  | Index (id, e) -> id ^ "[" ^ string_of_expr e ^ "]"
  (* operators*)
  | Binop (e1, op, e2) -> string_of_expr e1 ^ " " ^ string_of_binop op ^ " " ^ string_of_expr e2
  | Unop (op, e) -> (match op with
      Not -> string_of_unop op ^ " (" ^ string_of_expr e ^ ")"
    | Neg -> string_of_unop op ^ "(" ^ string_of_expr e ^ ")")
  (* other *)
  | Parentheses e -> "(" ^ string_of_expr e ^ ")"
  | Noexpr -> ""


(* wrap stuff in curly braces *)
let brace_wrap s =
  "{\n" ^
  s ^ "\n" ^
  "}"

let rec string_of_stmt = function
    Expr(e) -> string_of_expr e ^ ";"
  | Return(e) -> (match e with
      Noexpr -> "return;"
    | _   -> "return " ^ string_of_expr e ^ ";")
  | If (e, s1, elifs, s2) ->
      let if_str =
        "if " ^ string_of_expr e ^ "\n" ^
        brace_wrap (String.concat "\n" (List.map string_of_stmt s1)) in
      let string_of_elif (elif_e, elif_s) = 
        "elif " ^ string_of_expr elif_e ^ "\n" ^
        brace_wrap(String.concat "\n" (List.map string_of_stmt elif_s))
      in
      let elif_str = match elifs with 
          [] -> ""
        | _  -> "\n" ^
                String.concat "\n" (List.map string_of_elif elifs) in
      let else_str = match s2 with
          [] -> ""
        | _  -> "\n" ^
                "else\n" ^
                brace_wrap(String.concat "\n" (List.map string_of_stmt s2)) in
      if_str ^ elif_str ^ else_str
  | While(e, s) ->
      "while " ^ string_of_expr e ^ "\n" ^
      brace_wrap (String.concat "\n" (List.map string_of_stmt s))
  | For(id, e1, e2, s) ->
      "for " ^ id ^ " from " ^ string_of_expr e1 ^ " to " ^ string_of_expr e2 ^ "\n" ^
      brace_wrap (String.concat "\n" (List.map string_of_stmt s))
  | Break -> "break;"
  | Continue -> "continue;"
  | Bind(o, p, f) -> "bind( " ^ o ^ "." ^ p ^ ", " ^ f ^ ");"
  | Unbind(o, p, f) -> "unbind( " ^ o ^ "." ^ p ^", " ^ f ^ ");"

let string_of_vdecl (t, id) = string_of_typ t ^ " " ^ id ^ ";"

let string_of_odecl odecl =
  if odecl.extern then
    "external objdef " ^ odecl.oname ^ "\n" ^
    brace_wrap (String.concat "\n" (List.map string_of_vdecl odecl.props))
  else
    "objdef " ^ odecl.oname ^ "\n" ^
    brace_wrap (String.concat "\n" (List.map string_of_vdecl odecl.props))

let string_of_formal (t, id) = string_of_typ t ^ " " ^ id

let string_of_fdecl fdecl =
  "fn " ^ fdecl.fname ^ "("  ^ String.concat ", " (List.map string_of_formal fdecl.formals) ^ ") -> " ^ string_of_typ fdecl.typ ^ "\n" ^
  brace_wrap ((String.concat "\n" (List.rev (List.map string_of_vdecl fdecl.locals))) ^ "\n\n" ^
               String.concat "\n" (List.map string_of_stmt fdecl.body))

let string_of_program (vdecls, odecls, fdecls) =
  String.trim
  (String.concat "\n" (List.rev (List.map string_of_vdecl vdecls)) ^ "\n" ^
  String.concat "\n\n" (List.rev (List.map string_of_odecl odecls)) ^ "\n" ^
  String.concat "\n\n" (List.rev (List.map string_of_fdecl fdecls))) ^ "\n"
\end{lstlisting}

\subsection{\texttt{codegen.ml}}

\begin{lstlisting}[language=Caml,backgroundcolor=\color{backgroundcolor}]
(* Authors: Isra Ali, Gwendolyn Edgar, Randy Price, Chris Xiong *)
module L = Llvm
module A = Ast
open Sast

module StringMap = Map.Make(String)

let translate (globals, objects, functions) =
  let context = L.global_context () in

  let i32_t      = L.i32_type      context
  and i8_t       = L.i8_type       context
  and i1_t       = L.i1_type       context
  and float_t    = L.double_type   context
  and void_t     = L.void_type     context
  and the_module = L.create_module context "Propeller" in

  (* let objdef_strs = String.concat "\n" (List.map (fun o -> o.soname) objects) in *)

  let is_external = function
      A.Custom t ->
        let objdef = List.find (fun o -> o.soname = t) objects in
        objdef.sextern
    | _ -> false
  in
  
  let rec ltype_of_typ = function
      A.Int   -> i32_t
    | A.Float -> float_t
    | A.Bool  -> i1_t
    | A.Str ->  L.pointer_type (L.i8_type (context)) 
    | A.Void  -> void_t
    | A.Custom t ->
        let objdef = List.find (fun o -> o.soname = t) objects in
        let ptys = List.map fst objdef.sprops in
        let ltys = Array.of_list (List.map ltype_of_typ ptys) in
        if objdef.sextern then i32_t else L.struct_type context ltys
    | A.List(t) -> L.pointer_type (ltype_of_typ t)
    | _       -> i32_t
  in

  (* indices for struct getelementpointer *)
  let get_obj_gep_idx o p =
    let obj_geps = 
      let add_obj m odecl =
        let rec build_pmap n = function
            []         -> StringMap.empty
          | (_, p)::ps -> StringMap.add p n (build_pmap (n + 1) ps)
        in
        let pmap = build_pmap 0 odecl.sprops in
        StringMap.add odecl.soname pmap m
      in
      List.fold_left add_obj StringMap.empty objects in
    StringMap.find p (StringMap.find o obj_geps)
  in

  (* globals *)
  let global_vars : L.llvalue StringMap.t =
    let global_var m (t, n) = 
      let init = match t with
          A.Float -> L.const_float (ltype_of_typ t) 0.0
        | _ -> L.const_int (ltype_of_typ t) 0 in
      StringMap.add n (L.define_global n init the_module) m
    in
    List.fold_left global_var StringMap.empty globals in

  (* functions *)
  let print_t : L.lltype = L.var_arg_function_type i32_t [| L.pointer_type i8_t |] in
  let print_func : L.llvalue = L.declare_function "printf" print_t the_module in
  
  let function_decls : (L.llvalue * sfunc_decl) StringMap.t =
    let function_decl m fdecl =
      let name = fdecl.sfname
      and formal_types = Array.of_list (List.map (fun (t, _) -> ltype_of_typ t) fdecl.sformals) in
      let ftype = L.function_type (ltype_of_typ fdecl.styp) formal_types in
      StringMap.add name (L.define_function name ftype the_module, fdecl) m
    in
    List.fold_left function_decl StringMap.empty functions in

  (* global symbols *)
  let gsyms = List.fold_left (fun m (ty, name) -> StringMap.add name ty m)
                             StringMap.empty globals in


  (* ================ FUNCTION BODY ================ *)
  let build_function_body fdecl =

    let (the_function, _) = StringMap.find fdecl.sfname function_decls in
    let builder = L.builder_at_end context (L.entry_block the_function) in

    let int_format_str = L.build_global_stringptr "%d\n" "fmt" builder in
    let str_format_str = L.build_global_stringptr "%s" "fmt" builder in 
    let float_format_str = L.build_global_stringptr "%f\n" "fmt" builder in

    let local_vars =
      let add_formal m (t, n) p = 
        let () = L.set_value_name n p in
	      let local = L.build_alloca (ltype_of_typ t) n builder in
        let _  = L.build_store p local builder in
	      StringMap.add n local m
      in
      let add_local m (t, n) =
	      let local_var = L.build_alloca (ltype_of_typ t) n builder
	      in StringMap.add n local_var m 
      in
      let formals = List.fold_left2 add_formal StringMap.empty fdecl.sformals
                                    (Array.to_list (L.params the_function)) in
      List.fold_left add_local formals fdecl.slocals in
    
    let lookup n =
      try  StringMap.find n local_vars
      with Not_found -> StringMap.find n global_vars
    in
    
    (* type of symbols *)
    let fsyms = List.fold_left (fun m (ty, name) -> StringMap.add name ty m)
                                 StringMap.empty fdecl.sformals in
    let lsyms = List.fold_left (fun m (ty, name) -> StringMap.add name ty m)
	                               StringMap.empty fdecl.slocals in

    let type_of_identifier id =
      try StringMap.find id lsyms
      with Not_found -> 
        try StringMap.find id fsyms
        with Not_found -> 
          try StringMap.find id gsyms
          with Not_found -> raise (Failure ("Internal error - undefined identifier " ^ id))
    in
    
    let type_of_prop o p = 
      let objpropt = 
        let add_obj m odecl =
          let rec build_tmap = function
              []         -> StringMap.empty
            | (t, p)::ps -> StringMap.add p t (build_tmap ps)
          in
          let tmap = build_tmap odecl.sprops in
          StringMap.add odecl.soname tmap m
        in
        List.fold_left add_obj StringMap.empty objects in
      StringMap.find p (StringMap.find o objpropt)
    in

    (* get name of object type (objdef <type>) *)
    let type_of_obj o = match type_of_identifier o with
        A.Custom t -> t
      | _ -> raise (Failure (o ^ " is not an object"))
    in
    
    let extcreatef_t : L.lltype = L.function_type i32_t [| |] in
    
    let build_extern_local_init builder = 
      let init_extern_local builder (t, n) =
        if is_external (type_of_identifier n) then
          match t with
              A.Custom t ->
                let create_func : L.llvalue = L.declare_function ("object_new_" ^ t) extcreatef_t the_module in
                let r = L.build_call create_func [| |] "created" builder in
                let _ = L.build_store r (StringMap.find n local_vars) builder in
              builder
            | _ -> raise (Failure ("internal codegen error"))
        else builder
      in List.fold_left init_extern_local builder fdecl.slocals
    in
    
    (* ================ PROPERTY BINDING MAP ================ *)
    (* map of properties and their bound functions : string -> string list
       <var_name>__<prop_name> -> [<function names>] *)
    let bind_map = 
      (* names of local objects *)
      let local_obj_names =
        let is_obj = function
            (A.Custom _, _) -> true
          | _ -> false
        in
        let local_obj_vars = List.filter is_obj fdecl.slocals in
        List.map snd local_obj_vars in

      (* make keys for property-function bindings map *)
      let bind_map_keys =
        let rec make_bind_map_keys = function
            [] -> []
          | o::os -> let props =
                        let get_prop_names_of_var v =
                          let objdef = type_of_obj v in
                          let odecl = try List.find (fun od -> od.soname = objdef) objects
                                      with Not_found -> raise (Failure "can't find object") in
                          let oprops = odecl.sprops in
                          List.map snd oprops
                        in
                        get_prop_names_of_var o in
                        let make_key p =
                          o ^ "__" ^ p
                        in
                        (List.map make_key props) @ (make_bind_map_keys os)
        in
        make_bind_map_keys local_obj_names in

      (* let bind_map_keys = make_bind_map_keys local_obj_names in *)
      let make_empty_lists m k =
        StringMap.add k [] m
      in
      ref (List.fold_left make_empty_lists StringMap.empty bind_map_keys) in

    (* add binding to property*)
    let add_obj_bind o p f =
      let k = (o ^ "__" ^ p) in
      let fs = StringMap.find k !bind_map in
      if List.mem f fs
      then raise (Failure ("function " ^ f ^ " is already bound to " ^ o ^ "." ^ p))
      else
        let new_fs = f :: fs in
        let new_m = StringMap.add k new_fs !bind_map in
        bind_map := new_m
    in

    (* remove binding from property *)
    let rem_obj_bind o p f =
      let k = (o ^ "__" ^ p) in
      let fs = StringMap.find k !bind_map in
      if List.mem f fs
      then
        let new_fs = List.filter (fun n -> n <> f) fs in
        let new_m = StringMap.add k new_fs !bind_map in
        bind_map := new_m
      else raise (Failure ("function " ^ f ^ " is not bound to " ^ o ^ "." ^ p))
    in

    (* get a property's bound functions *)
    let get_bound_funcs o p =
      let k = (o ^ "__" ^ p) in
      StringMap.find k !bind_map
    in

    (* ================ EXPRESSION BUILDER ================ *)
    let rec expr builder ((_, e) : sexpr) = match e with
        SIliteral x -> L.const_int i32_t x
      | SFliteral x -> L.const_float float_t x
      | SBliteral x -> L.const_int i1_t (if x then 1 else 0)
      | SSliteral x ->  L.build_global_stringptr x "str" builder
      | SLliteral xs -> 
        let (x, _) = Array.get xs 0 in
        let allocate = L.build_array_alloca (ltype_of_typ x) (L.const_int i32_t (Array.length xs)) "tmp_list" builder in
        let build_list x i arr =
          let gep_ptr = L.build_gep arr [| L.const_int i32_t i |] "list" builder in
          let _ = L.build_store (expr builder x) gep_ptr builder in 
          i + 1    
        in
        let _ =  Array.fold_left (fun y el -> build_list el y allocate) 0 (Array.of_list (List.rev (Array.to_list xs))) in 
        allocate
      | SCall (f, es) -> (match (f, es) with
            ("print", [e]) | ("printb", [e]) ->
              L.build_call print_func [| int_format_str ; (expr builder e) |] "print" builder
          | ("prints", [e]) -> L.build_call print_func [| str_format_str ; (expr builder e) |] "print" builder
          | ("printf", [e]) -> L.build_call print_func [| float_format_str ; (expr builder e) |] "print" builder
          | _ -> let (fdef, fdecl) = StringMap.find f function_decls in
                 let lles = List.rev (List.map (expr builder) (List.rev es)) in
                 let result = (match fdecl.styp with 
                                    A.Void -> ""
                                  | _ -> f ^ "_result") in
                 L.build_call fdef (Array.of_list lles) result builder)
      | SAssign (id, e) ->
          let e' = expr builder e in
          let _ = L.build_store e' (lookup id) builder in
          e'
      | SSetprop (o, p, e) ->
        if is_external (type_of_identifier o)
        then
          raise (Failure "Property assignment to external objects is unimplemented")
        else
          let e' = expr builder e in
          let objtype = type_of_obj o in
          let idx = get_obj_gep_idx objtype p in
          let id = (o ^ "__" ^ p) in
          let tmp = L.build_struct_gep (lookup o) idx id builder in
          let _ = L.build_store e' tmp builder in
          let fs = get_bound_funcs o p in
          let call_bound_func f =
            expr builder (A.Void, SCall(f, [e; e]))
          in
          let _ = List.map call_bound_func fs in
          e'
      | SId id -> L.build_load (lookup id) id builder
      | SGetprop (o, p) ->
        if is_external (type_of_identifier o)
        then
          let oty = type_of_obj o in
          let pty = type_of_prop (type_of_obj o) p in
          let extgetf_t : L.lltype  = L.function_type (ltype_of_typ pty) [| i32_t |] in
          let get_func  : L.llvalue = L.declare_function ("object_prop_get_" ^ oty ^ "_" ^ p) extgetf_t the_module in
          L.build_call get_func [| (lookup o) |] "get_result" builder
        else
          let objtype = type_of_obj o in
          let idx = get_obj_gep_idx objtype p in
          let tmp = L.build_struct_gep (lookup o) idx (o ^ "__" ^ p) builder in
          L.build_load tmp (o ^ "__" ^ p) builder
      | SIndex (id, e) ->
        let id' = lookup id  in
        let indx = expr builder e in
        let head_ptr = L.build_load id' id builder in
        let elem_ptr  = L.build_gep head_ptr [|indx|] "p" builder in
        L.build_load elem_ptr "tmp" builder
      | SBinop (e1, op, e2) ->
          let (t, _) = e1
          and e1' = expr builder e1
          and e2' = expr builder e2 in
          let instr = (match t with
               A.Int -> (match op with
                             A.Add -> L.build_add
                           | A.Sub -> L.build_sub
                           | A.Mlt -> L.build_mul
                           | A.Div -> L.build_sdiv
                           | A.Mod -> L.build_srem
                           | A.Eq  -> L.build_icmp L.Icmp.Eq
                           | A.Neq -> L.build_icmp L.Icmp.Ne
                           | A.Lt  -> L.build_icmp L.Icmp.Slt
                           | A.Leq -> L.build_icmp L.Icmp.Sle
                           | A.Gt  -> L.build_icmp L.Icmp.Sgt
                           | A.Geq -> L.build_icmp L.Icmp.Sge
                           | _ -> raise (Failure "internal error - bad int operator"))
             | A.Float -> (match op with
                               A.Add -> L.build_fadd
                             | A.Sub -> L.build_fsub
                             | A.Mlt -> L.build_fmul
                             | A.Div -> L.build_fdiv 
                             | A.Eq  -> L.build_fcmp L.Fcmp.Oeq
                             | A.Neq -> L.build_fcmp L.Fcmp.One
                             | A.Lt  -> L.build_fcmp L.Fcmp.Olt
                             | A.Leq -> L.build_fcmp L.Fcmp.Ole
                             | A.Gt  -> L.build_fcmp L.Fcmp.Ogt
                             | A.Geq -> L.build_fcmp L.Fcmp.Oge
                             | _ -> raise (Failure "internal error - bad float operator"))
              | A.Bool -> (match op with
                               A.Eq  -> L.build_icmp L.Icmp.Eq
                             | A.Neq -> L.build_icmp L.Icmp.Ne
                             | A.And -> L.build_and
                             | A.Or  -> L.build_or
                             | A.Xor -> raise (Failure "internal error - bad float operator")
                             | _ -> raise (Failure "internal error - bad bool operator"))
              | _ -> raise (Failure ("internal error - bad binary operator type"))) in
          instr e1' e2' "tmp" builder
      | SUnop (op, e) ->
          let (t, _) = e in
          let e' = expr builder e in
          let instr = (match op with
                           A.Neg when t = A.Float -> L.build_fneg
                         | A.Neg when t = A.Int   -> L.build_neg
                         | A.Not when t = A.Bool  -> L.build_not
                         | _ -> raise (Failure "bad unary operator/operand")) in
          instr e' "tmp" builder
      | SParentheses e -> expr builder e
      | SNoexpr -> L.const_int i32_t 0
    in

    let add_terminal builder instr = match L.block_terminator (L.insertion_block builder) with
        Some _ -> ()
      | None -> ignore (instr builder)
    in

    (* ================ STATEMENT BUILDER ================ *)
    let rec stmt loop_start loop_after builder = function
        SExpr e -> let _ = expr builder e in builder
      | SReturn e -> 
          let _ = match fdecl.styp with
                      A.Void -> L.build_ret_void builder
                    | _      -> L.build_ret (expr builder e) builder in
          builder
      | SIf (e, s1, elifs, s2) ->

          (* convert elifs to nested SIf *)
          let s2' = (match elifs with
              [] -> s2
            | _  -> 
                let rec transform_elifs = function
                    [(elif_e, elif_s)]     -> SIf(elif_e, elif_s, [], s2)
                  | (elif_e, elif_s) :: es  -> SIf(elif_e, elif_s, [], [transform_elifs es])
                  | [] -> raise (Failure "semant internal error")
                in
                [transform_elifs elifs]) in

          (* merge block, branch to merge block instruction *)
          let merge_bb = L.append_block context "merge" the_function in
          let branch_instr = L.build_br merge_bb in

          (* add instruction builders for a list of statements to the end of a basic block *)
          let build_bb_stmts bb s =
            let build_bb_stmt st =
              stmt loop_start loop_after (L.builder_at_end context bb) st
            in
            List.map build_bb_stmt s
          in

          (* add terminal to end of list of statements *)
          let rec terminate = function
              [] -> ()
            | (t :: []) -> add_terminal t branch_instr
            | (_ :: ts) -> terminate ts
          in

          (* if *)
          let if_bool = expr builder e in
          let if_bb = L.append_block context "if" the_function in
          let if_builders = build_bb_stmts if_bb s1 in
          let () = terminate if_builders in

          (* else *)
          let else_bb = L.append_block context "else" the_function in
          let else_builders = (match s2' with
              [] -> [stmt loop_start loop_after (L.builder_at_end context else_bb) (SExpr (A.Int, SNoexpr))]
            | _ ->  build_bb_stmts else_bb s2') in
          let () = terminate else_builders in

          (* build stuff *)
          let _ = L.build_cond_br if_bool if_bb else_bb builder in
          L.builder_at_end context merge_bb

      | SWhile (e, s) ->
          let e_bb = L.append_block context "while" the_function in
          let _    = L.build_br e_bb builder in
          let s_bb = L.append_block context "while_body" the_function in
          let merge_bb = L.append_block context "merge" the_function in
          let while_builder = List.fold_left (stmt (Some e_bb) (Some merge_bb))
                              (L.builder_at_end context s_bb) s in
          let () = add_terminal while_builder (L.build_br e_bb) in
          let e_builder = L.builder_at_end context e_bb in
          let bool_val = expr e_builder e in
          let _ = L.build_cond_br bool_val s_bb merge_bb e_builder in
          L.builder_at_end context merge_bb
      | SFor (id, e1, e2, s) ->
          let b = stmt loop_start loop_after builder (SExpr (A.Int, SAssign(id, e1))) in
          let id_sexpr = (A.Int, SId id) in
          let cmp_sexpr = (A.Bool, SBinop(id_sexpr, A.Leq, e2)) in
          let int1_sexpr = (A.Int, SIliteral 1) in
          let add_sexpr = (A.Int, SBinop (id_sexpr, A.Add, int1_sexpr)) in
          let inc_sexpr = (A.Int, SAssign(id, add_sexpr)) in
          let inc_stmt = SExpr inc_sexpr in
          let while_stmts = s @ [inc_stmt] in
          stmt loop_start loop_after b (SWhile (cmp_sexpr, while_stmts))
      | SContinue ->
          (match loop_start with
            (Some bb) -> let _ = L.build_br bb builder in
                           builder
          | None -> raise (Failure "semant internal error"))
      | SBreak ->
          (match loop_after with
            (Some bb) -> let _ = L.build_br bb builder in
                           builder
          | None -> raise (Failure "semant internal error"))
      | SBind(o, p, f) ->
        if is_external (type_of_identifier o)
        then
          let oty = type_of_obj o in
          let pty = type_of_prop (type_of_obj o) p in
          let extboundfuncp_t : L.lltype = L.pointer_type (L.function_type void_t [| ltype_of_typ pty; ltype_of_typ pty |]) in
          let extbindf_t     : L.lltype = L.function_type void_t [| i32_t; extboundfuncp_t |] in
          let bind_func : L.llvalue = L.declare_function ("object_prop_bind_" ^ oty ^ "_" ^ p) extbindf_t the_module in
          let ov = L.build_load (lookup o) o builder in
          let _ = L.build_call bind_func [| ov; fst (StringMap.find f function_decls) |] "" builder in
          builder
        else let _ = add_obj_bind o p f in builder
      | SUnbind(o, p, f) ->
        if is_external (type_of_identifier o)
        then
          let oty = type_of_obj o in
          let pty = type_of_prop (type_of_obj o) p in
          let extboundfuncp_t : L.lltype = L.pointer_type (L.function_type void_t [| ltype_of_typ pty; ltype_of_typ pty |]) in
          let extbindf_t     : L.lltype = L.function_type void_t [| i32_t; extboundfuncp_t |] in
          let unbind_func : L.llvalue = L.declare_function ("object_prop_unbind_" ^ oty ^ "_" ^ p) extbindf_t the_module in
          let ov = L.build_load (lookup o) o builder in
          let _ = L.build_call unbind_func [| ov; fst (StringMap.find f function_decls) |] "" builder in
          builder
        else let _ = rem_obj_bind o p f in builder
    in

    let b = build_extern_local_init builder in
    let builder = List.fold_left (stmt None None) b fdecl.sbody in

    add_terminal builder (match fdecl.styp with
        A.Void -> L.build_ret_void
      | t -> L.build_ret (L.const_int (ltype_of_typ t) 0))
  in

  List.iter build_function_body functions;
  the_module
\end{lstlisting}

\subsection{\texttt{propeller.ml}}

\begin{lstlisting}[language=Caml,backgroundcolor=\color{backgroundcolor}]
(* Authors: Isra Ali, Gwendolyn Edgar, Randy Price, Chris Xiong *)
(* open Ast
open Sast *)

type action = Ast | Sast | LLVM_IR | Compile

let () =
  let action = ref Compile in
  let set_action a () =
    action := a
  in
  let speclist = [
    ("-a", Arg.Unit (set_action Ast), "Print the AST");
    ("-s", Arg.Unit (set_action Sast), "Print the SAST");
    ("-l", Arg.Unit (set_action LLVM_IR), "Print the generated LLVM IR");
    ("-c", Arg.Unit (set_action Compile), "Check and print the generated LLVM IR (default)");] in
  let usage_msg = "usage: ./toplevel.native [-a|-s|-l] [file.pr]" in
  let channel = ref stdin in
  Arg.parse speclist (fun file -> channel:= open_in file) usage_msg;

  let lexbuf = Lexing.from_channel !channel in
  let ast = Parser.program Scanner.token lexbuf in
  match !action with
      Ast -> print_string (Ast.string_of_program ast)
    | _ -> let sast = Semant.check ast in
      match !action with
          Ast -> ()
        | Sast    -> print_string (Sast.string_of_sprogram sast)
        | LLVM_IR -> print_string (Llvm.string_of_llmodule (Codegen.translate sast))
        | Compile ->
            let m = Codegen.translate sast in
            Llvm_analysis.assert_valid_module m;
            print_string (Llvm.string_of_llmodule m)

  (* let sast = Semant.check ast in
  print_string(Sast.string_of_sprogram sast) *)
\end{lstlisting}

\subsection{\texttt{sast.ml}}

\begin{lstlisting}[language=Caml,backgroundcolor=\color{backgroundcolor}]
(* Authors: Isra Ali, Gwendolyn Edgar, Randy Price, Chris Xiong *)
open Ast

type sobj_decl = {
  soname : string;
  sprops : bind list;
  sextern : bool }

type sexpr = typ * sx
and sx =
    SIliteral of int
  | SFliteral of float
  | SBliteral of bool
  | SSliteral of string
  | SLliteral of sexpr array
  | SCall of string * sexpr list
  | SAssign of string * sexpr
  | SSetprop of string * string * sexpr
  | SId of string
  | SGetprop of string * string
  | SIndex of string * sexpr
  | SBinop of sexpr * binop * sexpr
  | SUnop of unop * sexpr
  | SParentheses of sexpr
  | SNoexpr

type sstmt =
    SExpr of sexpr
  | SReturn of sexpr
  | SIf of sexpr * sstmt list * (sexpr * sstmt list) list * sstmt list
  | SFor of string * sexpr * sexpr * sstmt list
  | SWhile of sexpr * sstmt list
  | SBreak
  | SContinue
  | SBind of string * string * string
  | SUnbind of string * string * string

type sfunc_decl = {
  styp : typ;
  sfname : string;
  sformals : bind list;
  slocals : bind list;
  sbody : sstmt list }

type sprogram = bind list * obj_decl list * sfunc_decl list

let rec string_of_sexpr (t, e) = "(" ^ string_of_typ t ^ " : " ^ (match e with 
    SIliteral x -> string_of_int x
  | SFliteral x -> string_of_float x
  | SBliteral x -> if x then "true" else "false"
  | SSliteral x -> x
  | SLliteral xs -> "[" ^ String.concat ", " (Array.to_list (Array.map string_of_sexpr xs)) ^ "]"
  | SCall (f, es) -> f ^ "(" ^ String.concat ", " (List.map string_of_sexpr es) ^ ")"
  | SAssign (id, e) -> id ^ " = " ^ string_of_sexpr e
  | SSetprop (o, p, e) -> o ^ "." ^ p ^ " = " ^ string_of_sexpr e
  | SId id -> id
  | SGetprop (o, p) -> o ^ "." ^ p
  | SIndex (id, e) -> id ^ "[" ^ string_of_sexpr e ^ "]"
  | SBinop (e1, op, e2) -> string_of_sexpr e1 ^ " " ^ string_of_binop op ^ " " ^ string_of_sexpr e2
  | SUnop (op, e) -> (match op with
      Not -> string_of_unop op ^ " (" ^ string_of_sexpr e ^ ")"
    | Neg -> string_of_unop op ^ "(" ^ string_of_sexpr e ^ ")")
  | SParentheses e -> "(" ^ string_of_sexpr e ^ ")"
  | SNoexpr -> "") ^ ")"

  let string_of_sodecl odecl =
    if odecl.sextern then
      "external objdef " ^ odecl.soname ^ "\n" ^
      brace_wrap (String.concat "\n" (List.map string_of_vdecl odecl.sprops))
    else
      "objdef " ^ odecl.soname ^ "\n" ^
      brace_wrap (String.concat "\n" (List.map string_of_vdecl odecl.sprops))

let rec string_of_sstmt = function
    SExpr e -> string_of_sexpr e ^ ";"
  | SReturn e -> (match e with
        (Void, SNoexpr) -> "return;"
      | _            -> "return " ^ string_of_sexpr e ^ ";")
  | SIf (e, s1, elifs, s2) ->
      let if_str =
        "if " ^ string_of_sexpr e ^ "\n" ^
        brace_wrap (String.concat "\n" (List.map string_of_sstmt s1)) in
      let string_of_elif (elif_e, elif_s) = 
        "elif " ^ string_of_sexpr elif_e ^ "\n" ^
        brace_wrap(String.concat "\n" (List.map string_of_sstmt elif_s))
      in
      let elif_str = match elifs with 
          [] -> ""
        | _  -> "\n" ^
                String.concat "\n" (List.map string_of_elif elifs) in
      let else_str = match s2 with
          [] -> ""
        | _  -> "\n" ^
                "else\n" ^
                brace_wrap(String.concat "\n" (List.map string_of_sstmt s2)) in
      if_str ^ elif_str ^ else_str
  | SFor (id, e1, e2, s) ->
      "for " ^ id ^ " from " ^ string_of_sexpr e1 ^ " to " ^ string_of_sexpr e2 ^ "\n" ^
      brace_wrap (String.concat "\n" (List.map string_of_sstmt s))
  | SWhile (e, s) ->
        "while " ^ string_of_sexpr e ^ "\n" ^
        brace_wrap (String.concat "\n" (List.map string_of_sstmt s))
  | SBreak -> "break;"
  | SContinue -> "continue;"
  | SBind (o, p, f) -> "bind(" ^ o ^ "." ^ p ^ ", " ^ f ^ ");"
  | SUnbind(o, p, f) -> "unbind( " ^ o ^ "." ^ p ^", " ^ f ^ ");"

  (* | _ -> "NONE" *)

let string_of_sfdecl fdecl =
  "fn " ^ fdecl.sfname ^ "("  ^ String.concat ", " (List.map snd fdecl.sformals) ^ ") -> " ^ string_of_typ fdecl.styp ^ "\n" ^
  brace_wrap ((String.concat "\n" (List.rev (List.map string_of_vdecl fdecl.slocals))) ^ "\n\n" ^
               String.concat "\n" (List.map string_of_sstmt fdecl.sbody))

let string_of_sprogram (vdecls, odecls, fdecls) =
  String.concat "\n" (List.rev (List.map string_of_vdecl vdecls)) ^ "\n\n" ^
  String.concat "\n\n" (List.rev (List.map string_of_sodecl odecls)) ^ "\n\n" ^
  String.concat "\n\n" (List.rev (List.map string_of_sfdecl fdecls))
\end{lstlisting}

\subsection{\texttt{semant.ml}}

\begin{lstlisting}[language=Caml,backgroundcolor=\color{backgroundcolor}]
(* Authors: Isra Ali, Gwendolyn Edgar, Randy Price, Chris Xiong *)
open Ast
open Sast

module StringMap = Map.Make(String)

let check (globals, objects, functions) =

  (* global variables *)

  let check_binds kind to_check =
    let name_compare (_, n1) (_, n2) =
      compare n1 n2
    in
    let check_it checked binding = match binding with
        (Void, _) -> raise (Failure ("void " ^ kind))
      | (_, n1)   -> match checked with
          ((_, n2) :: _) when n1 = n2 -> raise (Failure ("duplicate " ^ kind))
        | _ -> binding :: checked
    in
    let _ = List.fold_left check_it [] (List.sort name_compare to_check) in
    to_check
  in

  let globals' = check_binds "global" globals in

  (* objects *)

  let check_obj odecl = {
    soname = odecl.oname;
    sprops = check_binds "property" odecl.props;
    sextern = odecl.extern }
  in

  let objects' = List.map check_obj objects in

  let add_obj map odecl = match odecl with
      _ when StringMap.mem odecl.soname map -> raise (Failure "duplicate objdef")
    | _ ->   StringMap.add odecl.soname odecl map
  in

  let object_decls = List.fold_left add_obj StringMap.empty objects' in

  let find_objdecl o =
    try StringMap.find o object_decls
    with Not_found -> raise (Failure ("undefined object " ^ o))
  in

  let get_prop p odecl =
    let f (_, name) =
      name = p
    in
    try  List.find f odecl.sprops
    with Not_found -> raise (Failure ("object type " ^ odecl.soname ^ " has no property " ^ p))
  in

  (* functions *)
  let built_in_decls =
    let add_bind map (name, t) = StringMap.add name
      { typ = Void;
        fname = name;
        formals = [(t, "x")];
        locals = [];
        body = []; } map
    in
     List.fold_left add_bind StringMap.empty 
    [ ("print", Int); ("prints", Str); ("printf", Float); ("printb", Bool)] in

  let add_func map fdecl = match fdecl with
      _ when StringMap.mem fdecl.fname built_in_decls -> raise (Failure (fdecl.fname ^ " is already a built-in function"))
    | _ when StringMap.mem fdecl.fname map            -> raise (Failure ("duplicate function " ^ fdecl.fname))
    | _ -> StringMap.add fdecl.fname fdecl map
  in

  let function_decls = List.fold_left add_func built_in_decls functions in

  let find_func f =
    try StringMap.find f function_decls
    with Not_found -> raise (Failure ("undefined function " ^ f))
  in

  let _ = find_func "init" in

  let check_function func =
    let loop_vars =
      let rec find_loop_vars = function
          [] -> []
        | (st::sts) -> (match st with
                          If (_, s1, elifs, s2) ->
                            let elif_stmts = List.map snd elifs in
                            (find_loop_vars s1) @ (List.flatten (List.map find_loop_vars elif_stmts)) @ (find_loop_vars s2) @ (find_loop_vars sts)
                        | For (id, _, _, s) -> (Int, id) :: find_loop_vars s
                        | While (_, s) -> (find_loop_vars s) @ (find_loop_vars sts)
                        | _ -> find_loop_vars sts)
      in
      find_loop_vars func.body in

    let check_locals kind to_check =
      let name_compare (_, n1) (_, n2) =
        compare n1 n2
      in
      let check_it checked binding = match binding with
          (Void, _) -> raise (Failure ("void " ^ kind))
        | (Custom o, n1) -> let _ = find_objdecl o in
                            (match checked with
                                ((_, n2) :: _) when n1 = n2 -> raise (Failure ("duplicate " ^ kind))
                              | _ -> binding :: checked)
        | (_, n1)   -> match checked with
            ((_, n2) :: _) when n1 = n2 -> raise (Failure ("duplicate " ^ kind))
          | _ -> binding :: checked
      in
      let _ = List.fold_left check_it [] (List.sort name_compare to_check) in
      to_check
    in

    let formals' = check_binds "formal" func.formals in
    let locals'  = check_locals "local" (func.locals @ loop_vars) in

    let check_assign lt rt msg =
      if   lt = rt
      then lt
      else raise (Failure msg)
    in

    let symbols = List.fold_left (fun m (ty, name) -> StringMap.add name ty m)
	                               StringMap.empty (globals' @ formals' @ locals') in

    let type_of_identifier s =
      try StringMap.find s symbols
      with Not_found -> raise (Failure ("undefined identifier " ^ s))
    in

    let rec expr = function
        Iliteral x -> (Int,   SIliteral x)
      | Fliteral x -> (Float, SFliteral x)
      | Bliteral x -> (Bool,  SBliteral x)
      | Sliteral x -> (Str,   SSliteral (Scanf.unescaped (String.sub x 1 ((String.length x) - 2))))
      | Lliteral xs ->
          let (ty, _) = expr (Array.get xs 0) in
          let eqty e =
            let (tt, _) = expr e in
            tt = ty
          in
          let tocheckedlit = function 
              Iliteral e -> (Int, SIliteral e)
            | Fliteral e -> (Float, SFliteral e)
            | Bliteral e -> (Bool, SBliteral e)
            | Sliteral e -> (Str, SSliteral e)
            | _ -> raise (Failure "invalid literal in list")
          in
          let same = List.fold_left ( = ) true (List.map eqty (Array.to_list xs)) in
          if   not same
          then raise (Failure "unequal list element types")
          else (match ty with
                    Int   -> let sxs = Array.map tocheckedlit xs in
                             (List(Int), SLliteral sxs)
                  | Float -> let sxs = Array.map tocheckedlit xs in
                             (List(Float), SLliteral sxs)
                  | Bool  -> let sxs = Array.map tocheckedlit xs in
                             (List(Bool), SLliteral sxs)
                  | Str   -> let sxs = Array.map tocheckedlit xs in
                             (List(Str), SLliteral sxs)
                  | _     -> raise (Failure "bad list type"))
      | Id id -> (type_of_identifier id, SId id)
      | Getprop (o, p) ->
          let otype = type_of_identifier o in
          (match otype with
              Custom t ->
                let odecl = find_objdecl t in
                let (pty, _) = get_prop p odecl in
                (pty, SGetprop(o, p))
            | _       -> raise (Failure (o ^ " is not an object")))
      | Index (id, e) ->
          let ty = (match type_of_identifier id with
                       List(t) -> t
                     | _      -> raise (Failure ("cannot index non-list variable " ^ id))) in
          let (t, e') = expr e in
          (match t with
              Int -> (ty, SIndex(id, (t, e')))
            | _   -> raise (Failure "list index expression must of type int"))
      | Call (f, es) ->
          let fdecl = find_func f in
          let fname = fdecl.fname in
          let n_form = List.length fdecl.formals in
          let n_args = List.length es in
          if   n_args != n_form
          then raise (Failure ("function " ^ fname ^ "expects " ^ (string_of_int n_form) ^
                               " arguments, but was passed " ^ (string_of_int n_args)))
          else
          let check_call (ft, _) e =
            let (et, e') = expr e in
            let err_msg = "bad argument types in call to " ^ fname in
            (check_assign ft et err_msg, e')
          in
          let es' = List.map2 check_call fdecl.formals es in
          (fdecl.typ, SCall(f, es'))
      | Assign (id, e) ->
          let tid = type_of_identifier id
          and (te, e') = expr e in
          let err_msg = "illegal assignment to " ^ id in
          (check_assign tid te err_msg, SAssign(id, (te, e')))
      | Setprop (o, p, e) ->
        let otype = type_of_identifier o in
        (match otype with
            Custom t ->
              let odecl = find_objdecl t in
              let (pt, _) = get_prop p odecl in
              let (et, e') = expr e in
              (check_assign pt et "illegal property assignment", SSetprop(o, p, (et, e')))
          | _        -> raise (Failure (o ^ " is not an object")))
      | Binop (e1, op, e2) ->
          let (t1, e1') = expr e1
          and (t2, e2') = expr e2 in
          let ty = match op with
              Add | Sub | Mlt | Div | Mod when t1 = t2 && t1 = Int   -> Int
            | Add | Sub | Mlt | Div       when t1 = t2 && t1 = Float -> Float
            | Eq  | Neq                   when t1 = t2               -> Bool
            | Lt  | Leq | Gt  | Geq       when t1 = t2 && (t1 = Int || t2 = Float) -> Bool
            | And | Or  | Xor             when t1 = t2 && t1 = Bool -> Bool
            | _ -> raise (Failure "illegal binary operator") in
          (ty, SBinop((t1, e1'), op, (t2, e2')))
      | Unop (op, e) ->
          let (t, e') = expr e in
          let ty = match op with
              Neg when t == Int || t == Float -> t
            | Not when t == Bool -> Bool
            | _ -> raise (Failure "illegal unary operator") in
          (ty, SUnop(op, (t, e')))
      | Parentheses e ->
          let (ty, e') = expr e in
          (ty, SParentheses (ty, e'))
      | Noexpr -> (Void, SNoexpr)
    in

    let check_bool_expr e =
      let (t', e') = expr e in
      if   t' != Bool
      then raise (Failure "expected boolean expression")
      else (t', e')
    in

    let check_int_expr e =
      let (t', e') = expr e in
      if   t' != Int
      then raise (Failure "expected int expression")
      else (t', e')
    in

    let rec check_stmt in_loop = function
        Expr e -> SExpr (expr e)
      | Return e ->
        let (ty, ex) = expr e in
        let _ = check_assign ty func.typ ("bad return type in function " ^ func.fname) in
        SReturn (ty, ex)
      | If (e, s1, elifs, s2) ->
          let check_elif (elif_e, elif_s) =
            (check_bool_expr elif_e, List.map (check_stmt in_loop) elif_s)
          in
          let elifs' = match elifs with
              [] -> []
            | _  -> List.map check_elif elifs in
          let s2' = match s2 with
              [] -> []
            | _  -> List.map (check_stmt in_loop) s2 in
          SIf (check_bool_expr e, List.map (check_stmt in_loop) s1, elifs', s2')
      | For (id, e1, e2, s) -> 
          SFor (id, check_int_expr e1, check_int_expr e2, List.map (check_stmt true) s)
      | While (e, s) -> SWhile (check_bool_expr e, List.map (check_stmt true) s)
      | Break    -> if not in_loop then raise (Failure "break outside loop") else SBreak
      | Continue -> if not in_loop then raise (Failure "continue outside loop") else SContinue
      | Bind (o, p, f) -> 
          let oty = type_of_identifier o in
          (match oty with
               Custom t ->
                 let odecl = find_objdecl t in
                 let (pty, _) = get_prop p odecl in
                 let fdecl = find_func f in
                 (match fdecl.formals with
                     (fty1, _) :: (fty2, _) :: [] ->
                        if fty1 != pty || fty2 != pty
                        then raise (Failure "type of property must match type of bound function arguments")
                        else
                        SBind (o, p, f)
                   | _ -> raise (Failure "bound functions must take 2 arguments"))
             | _ -> raise (Failure (o ^ " is not an object")))
      | Unbind (o, p, f) -> 
          let oty = type_of_identifier o in
          (match oty with
               Custom t ->
                 let odecl = find_objdecl t in
                 let _ = get_prop p odecl in
                 let _ = find_func f in
                 SUnbind (o, p, f)
               | _ -> raise (Failure (o ^ " is not an object")))
    in

    { styp = func.typ;
      sfname = func.fname;
      sformals = formals';
      slocals = locals';
      sbody = List.map (check_stmt false) func.body }
  in

  let functions' = List.map check_function functions in
  (globals', objects', functions')
\end{lstlisting}

\subsection{\texttt{default.c}}

\begin{lstlisting}[language=C,backgroundcolor=\color{backgroundcolor}]
extern int init(); 

int main() { return init(); }
\end{lstlisting}
